# 骑士游戏开发知识库

## 游戏概述
骑士游戏是一个基于HTML5 Canvas的2D横版闯关游戏，玩家控制一个骑士角色，通过跳跃、攻击和使用技能来击败敌人，最终挑战Boss。

## 技术架构
- **前端技术**：HTML5, CSS3, JavaScript (ES6+)
- **游戏引擎**：原生Canvas API，无第三方游戏引擎
- **设计模式**：面向对象编程，使用类来组织游戏逻辑
- **游戏循环**：基于requestAnimationFrame的游戏循环

## 核心组件

### 1. Knight类
骑士游戏的主要类，负责游戏的核心逻辑和渲染。

#### 主要方法
- `constructor()`: 初始化游戏画布、物理系统、游戏对象和摄像机等
- `init()`: 设置事件监听器、创建玩家和关卡、配置摄像机并启动游戏循环
- `gameLoop()`: 游戏主循环，处理游戏更新和渲染
- `update()`: 更新游戏状态
- `render()`: 渲染游戏画面
- `cleanup()`: 清理游戏资源

#### 游戏系统
- **物理系统**：重力、摩擦力、碰撞检测
- **战斗系统**：攻击、技能、连击
- **动画系统**：角色动画、粒子效果
- **摄像机系统**：跟随玩家移动

### 2. 游戏对象
- **玩家**：具有生命值、能量、攻击力等属性
- **敌人**：不同类型的敌人，具有不同的AI行为
- **Boss**：强大的敌人，具有特殊技能
- **平台**：游戏中的地形元素
- **收集品**：生命值、能量、金币等可收集物品
- **弹药**：玩家和敌人发射的攻击物
- **粒子**：各种视觉效果

### 3. 游戏状态管理
- **playing**: 游戏进行中
- **paused**: 游戏暂停
- **gameOver**: 游戏结束
- **victory**: 游戏胜利
- **menu**: 游戏菜单

## 开发挑战与解决方案

### 1. 资源管理
**挑战**：游戏切换时资源清理不彻底，导致内存泄漏和事件监听器重复绑定。

**解决方案**：
- 实现完整的cleanup方法，清理所有游戏资源
- 保存animationFrameId以便取消动画帧
- 移除所有事件监听器
- 清理所有游戏对象引用

### 2. 游戏循环优化
**挑战**：游戏循环需要高效运行，同时保持稳定的帧率。

**解决方案**：
- 使用requestAnimationFrame实现游戏循环
- 实现帧率控制，避免过度渲染
- 分离游戏逻辑更新和渲染

### 3. 碰撞检测
**挑战**：精确的碰撞检测对于游戏体验至关重要。

**解决方案**：
- 实现AABB（轴对齐边界框）碰撞检测
- 分离不同类型的碰撞处理（玩家-平台、玩家-敌人等）
- 实现碰撞响应（击退、伤害等）

## 未来改进方向

### 1. 游戏内容扩展
- 添加更多关卡和敌人类型
- 实现更复杂的Boss战斗
- 添加更多技能和升级系统

### 2. 性能优化
- 实现对象池管理，减少垃圾回收
- 优化渲染性能，减少不必要的绘制
- 实现资源预加载

### 3. 用户体验改进
- 添加音效和背景音乐
- 实现存档系统
- 添加游戏教程和提示

## 学习资源

### 1. Canvas API
- [MDN Canvas教程](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)
- [Canvas游戏开发指南](https://developer.mozilla.org/zh-CN/docs/Games/Techniques/2D_collision_detection)

### 2. JavaScript游戏开发
- [JavaScript游戏开发最佳实践](https://developer.mozilla.org/zh-CN/docs/Games/Techniques)
- [游戏循环设计模式](https://gameprogrammingpatterns.com/game-loop.html)

### 3. 游戏设计
- [游戏设计基础](https://learn.game-design.org/)
- [2D平台游戏设计原则](https://www.gamedesigning.org/learn/platformer/)

## 代码示例

### 游戏循环实现
```javascript
gameLoop(currentTime = 0) {
    // 检查游戏是否已停止
    if (this.gameState === 'stopped') {
        return;
    }
    
    if (this.gameState === 'paused') {
        this.animationFrameId = requestAnimationFrame((time) => this.gameLoop(time));
        return;
    }
    
    if (currentTime - this.lastTime < this.frameInterval) {
        this.animationFrameId = requestAnimationFrame((time) => this.gameLoop(time));
        return;
    }
    
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    this.frameCount++;
    
    this.update(deltaTime);
    this.render();
    
    this.animationFrameId = requestAnimationFrame((time) => this.gameLoop(time));
}
```

### 碰撞检测实现
```javascript
checkCollision(rect1, rect2) {
    if (!rect1 || !rect2) return false;
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}
```

### 资源清理实现
```javascript
cleanup() {
    console.log('清理骑士游戏资源...');
    
    // 移除事件监听器
    if (this.keydownHandler) {
        document.removeEventListener('keydown', this.keydownHandler);
    }
    if (this.keyupHandler) {
        document.removeEventListener('keyup', this.keyupHandler);
    }
    
    // 清理游戏对象
    this.player = null;
    this.enemies = [];
    this.boss = null;
    this.projectiles = [];
    this.particles = [];
    this.collectibles = [];
    this.platforms = [];
    
    // 清理动画帧
    if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
    }
    
    // 重置游戏状态
    this.gameState = 'paused';
    
    console.log('骑士游戏资源清理完成');
}
```